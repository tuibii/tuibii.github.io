{"meta":{"title":"talk is cheap,show me the code","subtitle":null,"description":null,"author":"liang","url":"https://wuy1liang.github.io","root":"/"},"posts":[{"tags":[{"name":"Java","slug":"Java","permalink":"https://wuy1liang.github.io/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://wuy1liang.github.io/tags/集合/"}],"title":"比较HashMap,HashTable,ConcurrentHashMap","date":"2020/03/23","text":"HashMapHashMap底层实现方式：JDK1.8之前是采用数组+链表，当产生哈希碰撞时，会采用头插法往链表中添加节点，在高并发的情况下，当HashMap扩容时可能会产生环形链表，导致get的时候陷入死循环。JDK1.8是采用数组+红黑树，当产生哈希碰撞时，改用尾插法插入，当节点个数 &gt; 8,链表会转化为红黑树，当结点个数 &lt; 6,红黑树会转化为链表。默认容量为16，载容因子为0.75。HashMap是线程不安全的。 HashTableHashTable是线程安全的，但是性能不好，因为他直接在方法上加了锁，并发时会阻塞其他线程。","permalink":"https://wuy1liang.github.io/2020/03/23/比较HashMap-HashTable-ConcurrentHashMap/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wuy1liang.github.io/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://wuy1liang.github.io/tags/集合/"}],"title":"Java的fail-fast与fail-safe机制","date":"2019/12/17","text":"fail-fast（快速失败）fail-fast是Java集合的一种错误检测机制，若一个方法不允许集合被多个线程同时修改，当方法检测到集合对象的并发修改时，就会抛出ConcurrentModificationException异常。java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。用List来举例： List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;0&quot;); list.add(&quot;1&quot;); list.add(&quot;2&quot;); list.add(&quot;3&quot;); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; String next = iterator.next(); System.out.println(next); if (next.equals(&quot;1&quot;))&#123; list.remove(next); &#125; &#125; 运行结果： 点开ArrayList的源码可以看到checkForComodification()这个方法 这个方法是异常抛出的地方 这个方法内容也很简单，就是比较modCount和expectedModCount这两个值 所以我们要搞清楚，到底modCount和expectedModCount这两个变量都是什么东西。 通过翻源码，我们可以发现：这段话的意思是modCount表示List的结构被修改的次数，结构修改是指List的大小被修改，即新增和删除操作，会改变modCount的值。modCount被迭代器使用，如果这个值被意外改变，就会抛出ConcurrentModificationException。 而expectedModCount 是 ArrayList中的一个内部类——Itr中的成员变量，其值的初始值即是modCount。 当List进行删除操作时，modCount+1，而expectedModCount却还是原先的值，所以当迭代器执行next方法时就会检测到集合的结构被改变了，所以就会抛出ConcurrentModificationException异常。 这也是为什么在阿里巴巴Java开发手册中，关于集合操作有这样一条强制规定：foreach 循环实际上是一个语法糖， foreach 对集合的遍历也是使用iterator迭代器迭代，所以当迭代器每一次迭代都会检查modCount和expectedModCount是否相等，所以在foreach循环中进行add/remove操作也会抛出ConcurrentModificationException异常。 fail-safe（安全失败）在并发包下的容器是采用fail-sale机制，它在遍历时不是直接在原集合内容上遍历的，而是先复制集合内容，在集合的拷贝上进行遍历，这样的遍历，由于在遍历过程中，集合的修改不会被迭代器检测到，也会不会抛出异常。基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 例如 java.util.concurrent.ConcurrentLinkedDeque; ConcurrentLinkedDeque&lt;String&gt; concurrentLinkedDeque = new ConcurrentLinkedDeque&lt;&gt;(); concurrentLinkedDeque.add(&quot;1&quot;); concurrentLinkedDeque.add(&quot;2&quot;); concurrentLinkedDeque.add(&quot;3&quot;); concurrentLinkedDeque.add(&quot;4&quot;); for (String num:concurrentLinkedDeque)&#123; concurrentLinkedDeque.remove(); System.out.println(&quot;num:&quot;+num); System.out.println(&quot;size:&quot;+concurrentLinkedDeque.size()); &#125; 运行结果：","permalink":"https://wuy1liang.github.io/2019/12/17/Java的fail-fast与fail-safe机制/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wuy1liang.github.io/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://wuy1liang.github.io/tags/算法/"}],"title":"模拟退火算法解旅行商问题","date":"2019/11/22","text":"最近要做一个旅游路线规划的应用，路线规划就是一个经典的旅行商问题 旅行商问题旅行商问题（Travelling salesman problem, TSP）是这样一个问题：给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。解旅行商问题有很多种算法，这些算法分两种：精确算法和近似算法，精确算法有：回溯法、动态规划等，近似算法有：贪心算法、蚁群算法、模拟退火算法、遗传算法等。精确算法一定可以解出最优解，但是时间复杂度很高，近似算法的效率就比准确算法高得多，缺点就是有一定概率得不到最优解。但是在大部分情况下，他都能算出最优解，即便得不到最优解，算出来的近似解也是十分接近最优解的，故我决定采用近似算法。上网查阅一些资料后我决定采用模拟退火算法。模拟退火算法(Simulated Annealing，SA)最早的思想是由N. Metropolis 等人于1953年提出。1983 年,S. Kirkpatrick 等成功地将退火思想引入到组合优化领域。它是基于Monte-Carlo迭代求解策略的一种随机寻优算法，其出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。模拟退火算法是一种通用的优化算法，理论上算法具有概率的全局优化性能,目前已在工程中得到了广泛应用，诸如VLSI、生产调度、控制工程、机器学习、神经网络、信号处理等领域。 模拟退火算法 退火在热力学上，退火（annealing）现象指物体逐渐降温的物理现象，温度愈低，物体的能量状态会低；够低后，液体开始冷凝与结晶，在结晶状态时，系统的能量状态最低。大自然在缓慢降温（亦即，退火）时，可“找到”最低能量状态：结晶。但是，如果过程过急过快，快速降温（亦称「淬炼」，quenching）时，会导致不是最低能态的非晶形。如下图所示，首先（左图）物体处于非晶体状态。我们将固体加温至充分高（中图），再让其徐徐冷却，也就退火（右图）。加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小（此时物体以晶体形态呈现）。 模拟退火在下图这个函数中，我们想要去找到最优解C，如果我们采用贪心算法，我们从A点开始搜索，每一次搜索都取当前局面的最优解，那么当到达B点时，我们就会停止搜索。模拟退火其实也是一种贪心算法，他也是在不断地搜索当前局面的最优解，但是它的搜索过程引入了随机因素。模拟退火算法会以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。当我们搜索到B点时，会有一定的概率去接受B点右边的不是局部最优的点，所以就有概率跳出局部最优解B，得到全局最优解C。总结：（1） 若f(x+1) &lt;= f(x)，即新解优于当前最优解，则接受这个新解为当前最优解。（2） 若f(x+1) &gt; f(x)，即新解不如当前最优解，则有一定概率接受这个新解为当前最优解。模拟退火算法从某一较高的温度出发，开始搜索当前最优解，一开始温度较高，变化的概率比较大，伴随温度参数的不断下降，变化的概率也逐渐下降，最后会逐渐趋向于稳定。 代码 /** 初始温度 */ double T = 5000.0; /** 温度下限 */ double T_min = 1e-8; /** 退货系数 */ double r = 0.98; /** 每个温度的迭代次数 */ int L = 100; /** 总迭代次数 */ int countL = 0; /** 退火次数 */ int countR = 0; while(T &gt; T_min)&#123; for (int i = 0;i &lt; L ;i++) &#123; /** 随机交换cop中两个点的顺序 */ cop = randomCity(cop); /** 计算 result 和 cop 两条回路的长度 */ double d1 = getDistance(result); double d2 = getDistance(cop); double de = d2 - d1; if (de &lt;= 0)&#123; result = cop; &#125;else &#123; if (Math.exp(-de/T)&gt;Math.random())&#123; result= cop; &#125; &#125; countL++; &#125; T = T * r; countR++; &#125; System.out.println(\"最优解：\"+result); System.out.println(\"退火次数：\"+countR); System.out.println(\"总迭代次数：\"+countL);","permalink":"https://wuy1liang.github.io/2019/11/22/模拟退火算法解旅行商问题/","photos":[]},{"tags":[{"name":"数据库","slug":"数据库","permalink":"https://wuy1liang.github.io/tags/数据库/"}],"title":"外键操作SQL生成","date":"2019/11/18","text":"组装禁用所有外键的语句select &apos;alter table &apos;||table_name||&apos; disable constraint &apos;||constraint_name||&apos;;&apos; from user_constraints where constraint_type=&apos;R&apos;; 组装启用所有外键的语句select &apos;alter table &apos;||table_name||&apos; enable constraint &apos;||constraint_name||&apos;;&apos; from user_constraints where constraint_type=&apos;R&apos;; 组装删除所有外键的语句select &apos;alter table &apos;||table_name||&apos; drop constraint &apos;||constraint_name||&apos;;&apos; from user_constraints where constraint_type=&apos;R&apos;; 查询所有外键select t.status,t.* from user_constraints t where constraint_type=&apos;R&apos;;","permalink":"https://wuy1liang.github.io/2019/11/18/外键操作SQL生成/","photos":[]},{"tags":[{"name":"数据库","slug":"数据库","permalink":"https://wuy1liang.github.io/tags/数据库/"},{"name":"Oracle","slug":"Oracle","permalink":"https://wuy1liang.github.io/tags/Oracle/"}],"title":"Oracle数据库全量导出","date":"2019/11/13","text":"今天需要把测试服务器数据库迁移到生产上，导出SQL和执行SQL都需要很长的时间，而导出和执行dmp文件，只需要几秒钟，就可以将数据库迁移到生产服务器上 导出dmp 切换Oracle角色su - oracle 导出exp 用户名/密码@orcl file=路径 owner=用户名 导入dmp 在目标机器上创建一个专用文件夹，比如imp_dmp，将dmp文件放入该文件夹；注：需要创建的文件不止log一个，所以给个文件夹并赋权最方便； 将该文件夹修改所有者：chown -R oracle:oinstall imp_dmp; 在目标机器上切换到oracle操作者：su - oracle此步是为了执行命令时可以获取到环境变量，否则会找不到imp命令 执行导入命令：imp 用户名/密码 file=dmp文件路径 log=log文件路径 fromuser=原数据库用户名 touser=用户名","permalink":"https://wuy1liang.github.io/2019/11/13/Oracle数据库全量导出/","photos":[]},{"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wuy1liang.github.io/tags/Linux/"},{"name":"文件服务器","slug":"文件服务器","permalink":"https://wuy1liang.github.io/tags/文件服务器/"}],"title":"FastDFS分布式文件服务器安装","date":"2019/09/26","text":"FastDFS是一款开源的分布式文件系统，功能主要包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了文件大容量存储和高性能访问的问题。FastDFS特别适合以文件为载体的在线服务，如图片、视频、文档等等。 安装gccyum install make cmake gcc gcc-c++ 下载libfastcommonwget https://github.com/happyfish100/libfastcommon/archive/V1.0.39.tar.gz -SO libfastcommon.tar.gz 解压 tar -xf libfastcommon.tar.gz 编译./make.sh 安装./make.sh install 下载fastdfswget https://github.com/happyfish100/fastdfs/archive/V5.11.tar.gz -SO fastdfs.tar.gz 解压tar -xf fastdfs.tar.gz 编译./make.sh 安装./make.sh install 程序在 /usr/bin 目录下 配置文件在 /etc/fdfs 目录下which fdfs_trackerdls /etc/fdfs配置文件是不完整的 把安装包中的配置文件拷贝到 /etc/fdfs 目录下sudo cp /usr/local/fastdfs/fastdfs-5.11/conf/* /etc/fdfs 启动服务fdfs_trackerd /etc/fdfs/tracker.conf startfdfs_storaged /etc/fdfs/storage.conf start","permalink":"https://wuy1liang.github.io/2019/09/26/FastDFS分布式文件服务器安装/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wuy1liang.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://wuy1liang.github.io/tags/多线程/"}],"title":"多线程笔记","date":"2019/07/25","text":"synchronized 关键字对某个对象加锁 public class T&#123; private int count = 10; public void m()&#123; synchronized (this)&#123; count--; System.out.println(Thread.currentThread().getName() + \"count = \" + count); &#125; &#125; &#125; 等同于 public class T&#123; private int count = 10; public synchronized void m()&#123; count--; System.out.println(Thread.currentThread().getName() + \"count = \" + count); &#125; &#125; 知识点 同步方法和非同步方法可以同时调用 写方法加锁，读方法不加锁，会产生脏读问题 一个同步方法可以调用另一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁，也就是说synchronized获得的锁是可重入的（子类调用父类的同步方法也是可以的） public class T&#123; synchronized void m()&#123; System.out.println(\"m start\") System.out.println(\"m end\") &#125; public static void main(String[] args) &#123; new TT().m(); &#125; &#125; class TT extends T&#123; synchronized void m()&#123; System.out.println(\"child start\") super.m(); System.out.println(\"child end\") &#125; &#125; 程序在执行过程中，如果出现异常，默认情况锁会被释放，如果不想释放需要处理异常 volatile 关键字 使一个变量在多个线程间可见A B线程都用到一个变量，java默认是A线程缓冲区中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道在下面的代码中，running是存在于堆内存的t对象中，当线程t1开始运行的时候，running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去读取堆内存，这样当主线程修改running 的值后，t1线程感知不到，所以不会停止运行public class T&#123; volatile boolean running = true; void m()&#123; System.out.println(\"start\"); while(running)&#123; &#125; System.out.println(\"end\"); &#125; public static void main(String[] args) &#123; T t = new T(); new Thread(t::m,\"t1\").start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; t.running = false; &#125; &#125;","permalink":"https://wuy1liang.github.io/2019/07/25/多线程笔记/","photos":[]},{"tags":[{"name":"数据库","slug":"数据库","permalink":"https://wuy1liang.github.io/tags/数据库/"},{"name":"mysql","slug":"mysql","permalink":"https://wuy1liang.github.io/tags/mysql/"}],"title":"mysql笔记","date":"2019/07/17","text":"先抛出几个问题 1.为什么不建议使用订单号作为主键？ 2.为什么要在需要排序的字段上加上索引？ 3.for update的记录不存在会导致锁住全表？ 4.redolog和binlog有什么区别？ 5.mysql如何回滚一条sql？ 6.char(50)和varchar(50)效果是一样的吗？ 索引对于 MySQL 数据库而言,数据是存储在文件里的，而为了能够快速定位到某张表里的某条记录进行查询和修改,我们需要将这些数据以一定的数据结构进行存储，这个数据结构就是我们说的索引。回忆一下我们大学里学过的算法与数据结构，能够支持快速查找的数据结构有：顺序数组、哈希、搜索树。 数组要求 insert 的时候保证有序，这样查找的时候可以利用二分查找法达到 O(log(N)) 的时间复杂度，对范围查询支持也很好，但是 insert 的时候如果不是在数组尾部，就需要摞动后面所有的数据，时间复杂度为 O(N) 。所以有序数组只适合存储静态数据，例如几乎很少变动的配置数据，或者是历史数据。这里应该会有人有疑问：我用另外一种线性数据结构链表来替代数组不就可以解决数组因为要移动数据导致太慢的问题了么，要回答这个问题我们需要了解操作系统读取文件的流程，磁盘 IO 是一个相对很慢的操作，为了提高读取速度，我们应该尽量减少磁盘 IO 操作，而操作系统一般以 ４kb 为一个数据页读取数据，而 MySQL 一般为 16kb 作为一个数据块，已经读取的数据块会在内存进行缓存，如果多次数据读取在同一个数据块，则只需要一次磁盘 IO ，而如果顺序一致的记录在文件中也是顺序存储的，就可以一次读取多个数据块，这样范围查询的速度也可以大大提升，显然链表没有这方面的优势。 类似于 jdk 中的 hashmap ，哈希表通过一个特定的哈希函数将 key 值转换为一个固定的地址，然后将对应的 value 放到这个位置，如果发生哈希碰撞就在这个位置拉出一个链表，由于哈希函数的离散特性，所以经过哈希函数处理后的 key 将失去原有的顺序，所以哈希结构的索引无法满足范围查询，只适合等值查询的情况例如一些缓存的场景。 二叉树在极端情况下会变成线性结构，也就是每个节点都只有左子节点或者只有右子节点，这样就无法利用二分查找只能从第一个节点开始向后遍历了，所以为了维持 O(log(N)) 的时间复杂度，我们需要在插入节点的时候对节点进行调整以保证树的平衡，所以平衡二叉树插入的时间复杂度也是 O(log(N)) ，二叉树只有两个子节点，如果数据量很大则树就很高，树的每一层一般不在同一个数据块中存储，为了尽量的减少磁盘读写次数，我们用Ｎ叉树来代替二叉树，在 MySQL 中这个Ｎ一般为 1200 ，这样树高是 ４ 的话也可以存储亿级别的数据，而且树的前面两层一般都在内存中， MySQL 中用到的 Ｂ＋ 树，一般用非叶子节点构建索引，而叶子节点用来存储具体的值。 InnoDB 中，有聚簇索引和普通索引之分，聚簇索引根据主键来构建，叶子节点存放的是该主键对应的这一行记录，而普通索引根据申明这个索引时候的列来构建，叶子节点存放的是这一行记录对应的主键的值，而普通索引中还有唯一索引和联合索引两个特例，唯一索引在插入和修改的时候会校验该索引对应的列的值是否已经存在，而联合索引将两个列的值按照申明时候的顺序进行拼接后在构建索引。 根据以上描述我们可以得到以下信息：数据是以行为单位存储在聚簇索引里的，根据主键查询可以直接利用聚簇索引定位到所在记录，根据普通索引查询需要先在普通索引上找到对应的主键的值，然后根据主键值去聚簇索引上查找记录，俗称回表。 普通索引上存储的值是主键的值，如果主键是一个很长的字符串并且建了很多普通索引，将造成普通索引占有很大的物理空间，这也是为什么建议使用 自增ID 来替代订单号作为主键，另一个原因是 自增ID 在 insert 的时候可以保证相邻的两条记录可能在同一个数据块，而订单号的连续性在设计上可能没有自增ID好，导致连续插入可能在多个数据块，增加了磁盘读写次数。 存储格式未完待续。。","permalink":"https://wuy1liang.github.io/2019/07/17/mysql笔记/","photos":[]}]}